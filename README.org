* Introduction

Diagram Make Language for Common Lisp.You can look DML as Domain Specific Language for drawing UML. 

我国同学，请参考[[https://github.com/cuichaox/dml/blob/dev/README.zh.org][中文说明]]

* Install

If you use quicklisp. To install dml to '~/quicklisp/local-projects/', in your shell:
#+BEGIN_SRC shell
$ cd ~/quicklisp/local-projects/
$ git clone https://github.com/cuichaox/dml.git
#+END_SRC 

System 'dml' will then be loadbale via (ql:quickload :dml). 
The systems that dml depended on (donuts, cl-cario2 etc.) 
will automatically download to local disk on the first loading.

#+BEGIN_SRC lisp
(ql:quickload :dml)
#+END_SRC 

* Quick start by examples

To run examples, load dml system and change current package to 'dml'. 

#+BEGIN_SRC lisp
(ql:quickload :dml)
(use-package :dml) ;; or (in-package :dml)
#+END_src 

** Quick Start for Sequence Diagram

 1. A synchronous message & retrun in a formated string : '==>' <object name> '.' <message label> '/' <return label>
 2. A asynchronous message in a formated string: '-->' <object name> '.' <message label>
 3. A new message in a fromated string : 'n->' <object> '.' <object name > '.' <mesasge label>
 4. Any object name begin with '!' is a active object
 5. A sequence list of messages in macro '&prog'
 6. A message with follwing sub-messages in mcaro '&chain'
 7. A optional/alternative frame with guard condtion and  messages in macro '&opt' or '&if'
 8. A loop frame with guard and message in macro '&loop'
 9. Any macro ('&prog' ,'&chain', '&opt', '&if' and '&loop') can be nested in each other

*** Examples of Sequence Diagram

Evalate expression:

#+BEGIN_SRC lisp
(dml-create-sequence "legend" ()
  (&prog "==>ObjectA.SyncMsg1()/ret1" 
         (&chain "==>ObjectA.SyncMsg2()/ret2"
                 "==>ObjectB.SyncMsg2.1()/ret2.1"
                 "-->!ActiveObjectC.AsyMesg2.2()")))
#+END_SRC

Will output image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/legend.png][file:demo/legend.png]] 


Evalate Expression:

#+BEGIN_SRC lisp
(dml-create-sequence "nested" ()
  (&chain "==>aComputer.play()/"
          (&prog (&chain "==>emacs.run()/"
                         "==>slime.load()/")
                 (&chain "==>slime.Hacking()/"
                         (&chain "==>slime.LookupHyperSpec()"
                                 (&prog "==>chrome:Explorer.Start()/"
                                        "==>chrome:Explorer.OpenSpec()/"))))))
#+END_SRC

Will output image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/nested.png][file:demo/nested.png]] 

Evalate Expression:

#+BEGIN_SRC lisp
(dml-create-sequence "control" ()
  (&chain "==>:PersonFile.LoadAllGoodMan()/"
          (&loop "[ hasNext ]"
                 (&prog "==>:PersonFile.readNext()/"
                        (&if "[ Is Good Man ]"
                             (&prog "n=>aManObj.new"
                                    "==>manPool.register()/"))))))
#+END_SRC

Will output image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/control.png][file:demo/control.png]] 

** Quick Start for Graph Diargam

1. Define Graph by edges that linked nodes. 
2. Define nodes by functions ( name of node is the first argument ):'full-class', 'simp-class', 'actor', 'pack', 'ucas', 'comp' 
3. Get Predefined node by name '@name'.
4. Define edges by functions (two nodes is arguments): '-dep-', '-com-', '-agg-', '-gen-by-'.

*** Examples of Graph Diagram

Evalate expression:

#+BEGIN_SRC lisp
(dml-create-graph "dml-component" (:rankdir :LR)
  (-dep-- "use"
          (comp "DML")
          (comp "donuts")
          (comp "Graphviz")))
#+END_SRC


Will output image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/dml-component.png][file:demo/dml-component.png]] 



Evalate expression:
#+BEGIN_SRC lisp
(dml-create-graph "os-class" ()
  (with-method ("+ play () : Love" "+ work () : Hate")
    (-genby-*
     (full-class "OS"
                 "abstract"
                 (attributes "- name : String"
                             "- born : Date"))
     (full-class "Linux")
     (full-class "Android")
     (full-class "Apple")
     (full-class "Windows"))
    (-dep- "from"
           (@name "Android")
           (@name"Linux"))))
#+END_SRC

Will output Image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/os-class.png][file:demo/os-class.png]] 

Evalate expression:

#+BEGIN_SRC lisp
(dml-create-graph "coder-case" (:rankdir :LR)
  (->> (actor "coder")
       (ucas "Use Emacs")
       (ucas "Programing")
       (ucas "Play game"))
  (-dep- "extend"
         (@name "Programing")
         (@name "Use Emacs")))
#+END_SRC lisp

Will output Image:

[[https://raw.githubusercontent.com/cuichaox/dml/master/demo/coder-case.png][file:demo/coder-case.png]] 


* Reference 


** Symbol for Sequence Diagram

| Symbol name        | Type  | Description                                         |
|--------------------+-------+-----------------------------------------------------|
| dml-create-sequnce | Macro | Dump sequnce diagram to ps and png file             |
| &prog              | Macro | Define sequnce calls                                |
| &chain             | Macro | Define a call with sub calls                        |
| &if                | Macro | Define two alternative calls with a guard condition |
| &loop              | Macro | Defile a call in a loop with a guard condition      |



** Symbol for Graph Diagram

 | Symbol name           | Type     | Description                                        |
 |-----------------------+----------+----------------------------------------------------|
 | dml-create-graph      | Macro    | Dump graph diagram to ps and png file.             |
 | full-class            | Function | Create a class node whih attributes and methods.   |
 | attributes, methods   | Function | Define attribute/method list for the full-calss    |
 | simp-class            | Function | Return a class node with a simple name in the box. |
 | with-method           | Macro    | Create to define share methods for classes.        |
 | actor                 | Function | Create a stick man as actor.                       |
 | pack                  | Function | Create a package node.                             |
 | ucas                  | Function | Create use case node.                              |
 | comp                  | Function | Create component node                              |
 | @name                 | Function | Reference pre-defined node by name                 |
 | ->, ->>               | Function | Define a arrow edge: 1-to-1, 1-to-n                |
 | -dep-, -dep-*, -dep-- | Function | Define dependcy edge: 1-to-1, 1-to-n, 1-by-1       |
 | -com-, com-*          | Function | Define composition edge: 1-to-1, 1-to-n            |
 | -agg-, -agg-*         | Function | Define a aggregation edge: 1-to-1, 1-to-n          |
 | -genby-,genby-*       | Function | Define generalize edge: 1-to-1, 1-to-n             |

